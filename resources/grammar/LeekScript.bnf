{
  parserClass="com.plopiplop.leekwars.parser.LeekScriptParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="LS"
  psiImplClassSuffix="Impl"
  psiPackage="com.plopiplop.leekwars.psi"
  psiImplPackage="com.plopiplop.leekwars.psi.impl"
  psiImplUtilClass="com.plopiplop.leekwars.psi.LSPsiImplUtil"

  elementTypeHolderClass="com.plopiplop.leekwars.psi.LSTypes"
  elementTypeClass="com.plopiplop.leekwars.psi.LSElementType"
  tokenTypeClass="com.plopiplop.leekwars.psi.LSTokenType"

  implements("(functionDeclaration|variableDeclaration|variableReference|parameter|methodCall|forInitializer)")="com.plopiplop.leekwars.psi.LSNamedElement"
  mixin("(functionDeclaration|variableDeclaration|variableReference|parameter|methodCall|forInitializer)")="com.plopiplop.leekwars.psi.LSNamedElementImpl"

  tokens=[
    identifier='regexp:(\p{Alpha}|_)\w*'
    number='regexp:\d+(\.\d*)?'
    string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
    comment='regexp://.*'
    multiline_comment='regexp:/\*([^\*]|\*[^/])*\*/'

    kw_function='function'
    kw_var='var'
    kw_global='global'
    kw_if='if'
    kw_else='else'
    kw_while='while'
    kw_do='do'
    kw_for='for'
    kw_in='in'
    kw_null='null'
    kw_true='true'
    kw_false='false'
    kw_return='return'
    kw_break='break'
    kw_continue='continue'
    kw_include='include'

    op_inc='++'
    op_dec='--'
    op_plus='+'
    op_minus='-'
    op_times='*'
    op_divide='/'
    op_modulo='%'
    op_semicolon=';'
    op_colon=':'
    op_lparen='('
    op_rparen=')'
    op_lbracket='['
    op_rbracket=']'
    op_lbrace='{'
    op_rbrace='}'
    op_comma=','
    op_plus_eq='+='
    op_minus_eq='-='
    op_times_eq='*='
    op_divide_eq='/='
    op_and_eq='&='
    op_or_eq='|='
    op_assign='='
    op_exclamation_mark='!'
    op_not='not'
    op_logical_or='||'
    op_logical_and='&&'
    op_or='or'
    op_and='and'
    op_le='<='
    op_lt='<'
    op_ge='>='
    op_gt='>'
    op_identity_equals='==='
    op_equals='=='
    op_identity_not_equals='!=='
    op_not_equals='!='
    op_binary_or='|'
    op_binary_and='&'
    op_reference='@'
    op_ternary='?'
  ]
}

program ::= sourceElements? <<eof>>

private sourceElements ::= sourceElement+
private sourceElement ::= functionDeclaration | statement | include | multiline_comment

private statement ::=
        block
    |   variableStatement
    |   emptyStatement
    |   expressionStatement
    |   ifStatement
    |   whileStatement
    |   doWhileStatement
    |   forStatement
    |   returnStatement
    |   breakStatement
    |   continueStatement

include ::= 'include' '(' referenceString ')' eos {pin=1}
referenceString ::= string {methods=[getReference]}
functionDeclaration ::= 'function' identifier '(' formalParameterList? ')' block {methods=[getSignature getNbArguments getPresentation]}

block ::= '{' statementList? '}'
statementList ::= statement+

variableStatement ::= modifier variableDeclarationList eos {methods = [isGlobal] pin=1}
private variableDeclarationList ::= variableDeclaration (',' variableDeclaration)*
variableDeclaration ::= identifier initialiser? {methods=[getPresentation] pin=1}
initialiser ::= '=' singleExpression {pin=1}

emptyStatement ::= ';'
expressionStatement ::= expressionSequence eos {pin=1}
expressionSequence ::= singleExpression (',' singleExpression)*

ifStatement ::= 'if' '(' expressionSequence ')' thenBlock elseBlock? {pin=1}
thenBlock ::= statement
elseBlock ::= 'else' statement
whileStatement ::= whileCondition statement
whileCondition ::= 'while' '(' expressionSequence ')' {pin=1}
doWhileStatement ::= 'do' statement whileCondition eos  {pin=1}
forStatement ::= 'for' '(' forInitializer ((':' forInitializer)? 'in' simpleExpression | initialiser ';' singleExpression ';' singleExpression) ')' statement {pin=1}
forInitializer ::= 'var'? identifier
returnStatement ::= 'return' expressionSequence? eos {pin=2}
breakStatement ::= 'break' eos  {pin=1}
continueStatement ::= 'continue' eos  {pin=1}

singleExpression ::=
//        'function' identifier? '(' formalParameterList ')' '{' functionBody '}'
        simpleExpression comparator singleExpression
    |   simpleExpression booleanOperator singleExpression
    |   simpleExpression mathOperator singleExpression
    |   simpleExpression '?' simpleExpression ':' simpleExpression
    |   variableReference assignmentOperator singleExpression
    |   simpleExpression

simpleExpression ::=
        variableReference postfixOperator
//    |   methodCall
    |   prefixOperator singleExpression
    |   variableReference
    |   '(' expressionSequence ')'
    |   literal
    |   arrayLiteral

variableReference ::= (methodCall | identifier) ('[' expressionSequence ']')*
methodCall ::= identifier arguments {methods=[getNbArguments]}

eos ::= ';'

arguments ::= '(' argumentList? ')'
argumentList ::= singleExpressionPart (',' singleExpressionPart)* {recoverWhile=singleExpressionRecover}
private singleExpressionRecover ::= !(')')
private singleExpressionPart ::= singleExpression {recoverWhile=singleExpressionPartRecover}
private singleExpressionPartRecover ::= !(')' | ',')

formalParameterList ::= parameter (',' parameter)*
parameter ::= '@'? identifier

private comparator ::= '<=' | '>=' | '<' | '>' | '===' | '==' | '!==' | '!='
private booleanOperator ::= '&&' | '||' | '&' | '|' | 'and' | 'or'
modifier ::= 'var' | 'global'
postfixOperator ::= '++' | '--'
prefixOperator ::= postfixOperator | '+' | '-' |  '!' | 'not'
private mathOperator ::= '+' | '-' | '*' | '/' | '%'
private assignmentOperator ::= '=' | '+=' | '-=' | '*=' | '/=' | '&=' | '|='
literal ::= 'null' | 'true' | 'false' | string | number

arrayLiteral ::= '[' (keyvalList | elementList)? ']'
elementList ::= singleExpression (',' singleExpression)*
keyvalList ::= keyval (',' keyval)*
keyval ::= singleExpression ':' singleExpression